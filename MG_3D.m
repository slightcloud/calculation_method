%**************************************************************************
% 该子函数使用多格点的方法求解电势
%**************************************************************************
function phi = MG_3D(rho,nx,ny,nz,tol,w,its_f,its_c,phi_in)
%***************************************************************
% rho代表的是每个格点上的电荷密度；
% nx代表的是系统x方向的格点总数；
% ny代表的是系统y方向的格点总数；
% nz代表的是系统z方向的格点总数；
% tol代表的是迭代结果的容差；
% w代表的是松弛因子
% its_f代表的是初期在细化网格上的求解次数
% its_c代表的是残差在粗化网格上的求解次数
% phi_in代表的是电势迭代的初始值，该值使用上一次迭代求出的结果以提高速度
%***************************************************************
global dg EPS0       % 声明全局变量
solver_it = 20000;   % 迭代步数
phi = phi_in;        % 给电势赋初值，初值为上一次求出的电势，希望能够提高收敛速度
nx_c = ceil(nx/2);   % x方向的粗化格点数
ny_c = ceil(ny/2);   % y方向的粗化格点数
nz_c = ceil(nz/2);   % z方向的粗化格点数
dg_c = 2*dg;         % 粗化格点的间距

R_f = zeros(nx,ny,nz);        % 用于存储细化网格的残差
R_c = zeros(nx_c,ny_c,nz_c);  % 用于存储粗化网格的残差

eps_f = zeros(nx,ny,nz);      % 用于存储细化网格格点上的误差，eps = phi(n)-phi_real

%**************************************************************************
% 开始主循环
%**************************************************************************
for ts = 1:solver_it
    
    % 1) 在细化网格上迭代几次
    for n = 1:its_f
        for i = 2:nx-1
            for j = 2:ny-1
                for k = 2:nz-1
                    g = 1/6*((rho(i,j,k)/EPS0)*dg*dg+phi(i+1,j,k)+phi(i-1,j,k)+...
                        phi(i,j+1,k)+phi(i,j-1,k)+phi(i,j,k+1)+phi(i,j,k-1));
                    phi(i,j,k) = phi(i,j,k)+w*(g-phi(i,j,k));
                end
            end
        end
    end
    
    % 2) 在细化网格上计算残差，R = A*phi+rho/EPS0
    R_f(2:nx-1,2:ny-1,2:nz-1) = rho(2:nx-1,2:ny-1,2:nz-1)/EPS0+(phi(3:nx,2:ny-1,2:nz-1)+phi(1:nx-2,2:ny-1,2:nz-1)+...
        phi(2:nx-1,3:ny,2:nz-1)+phi(2:nx-1,1:ny-2,2:nz-1)+phi(2:nx-1,2:ny-1,3:nz)+phi(2:nx-1,2:ny-1,1:nz-2)-6*phi(2:nx-1,2:ny-1,2:nz-1))/(dg*dg); 
    
    % 2b) 检查收敛情况
    r_sum = sum(sum(sum(R_f.^2)));          % 求出所有残差的和
    norm = sqrt(r_sum/(nx*ny*nz));          % 平均每个格点的残差值，实际上是一个标准差
    fprintf('The residual is %g\n',norm);
    if norm < tol                           %将平均残差与设定容差进行对比，若满足残差要求则停止循环
        clc;
        break;
    end
    
    % 3) 将细化网格上的残差重新分配到粗化网格上
    R_c(0.5*((3:2:nx-2)+1),0.5*((3:2:ny-2)+1),0.5*((3:2:nz-2)+1)) =...
        1/12*(R_f(2:2:nx-3,3:2:ny-2,3:2:nz-2)+2*R_f(3:2:nx-2,3:2:ny-2,3:2:nz-2)+R_f(4:2:nx-1,3:2:ny-2,3:2:nz-2)+...
        R_f(3:2:nx-2,2:2:ny-3,3:2:nz-2)+2*R_f(3:2:nx-2,3:2:ny-2,3:2:nz-2)+R_f(3:2:nx-2,4:2:ny-1,3:2:nz-2)+...
        R_f(3:2:nx-2,3:2:ny-2,2:2:nz-3)+2*R_f(3:2:nx-2,3:2:ny-2,3:2:nz-2)+R_f(3:2:nx-2,3:2:ny-2,4:2:nz-1));
    
    % 4) 在粗化网格上将误差迭代几次
    eps_c = zeros(nx_c,ny_c,nz_c);      %定义粗化网格的误差，eps = phi(n)-phi_real
    for n = 1:its_c
       for i = 2:nx_c-1
            for j = 2:ny_c-1
                for k = 2:nz_c-1
                    g = 1/6*(-dg_c*dg_c*R_c(i,j,k)+eps_c(i+1,j,k)+eps_c(i-1,j,k)+...
                        eps_c(i,j+1,k)+eps_c(i,j-1,k)+eps_c(i,j,k+1)+eps_c(i,j,k-1));
                    eps_c(i,j,k) = eps_c(i,j,k)+w*(g-eps_c(i,j,k));
                end
            end
        end
    end
    
    % 5) 将粗化网格上的误差插值到细化网格上
    eps_f(3:2:nx-2,3:2:ny-2,3:2:nz-2) = eps_c(0.5*((3:2:nx-2)+1),0.5*((3:2:ny-2)+1),0.5*((3:2:nz-2)+1));
    eps_f(2:2:nx-1,2:2:ny-1,2:2:nz-1) = 0.5*(eps_c(0.5*(2:2:nx-1),0.5*(2:2:ny-1),0.5*(2:2:nz-1))+...
        eps_c(0.5*(2:2:nx-1)+1,0.5*(2:2:ny-1)+1,0.5*(2:2:nz-1)+1));
    
    % 6) 在细化网格上更新电势的解
    phi = phi-eps_f;
    
end